import { IGitService, GitStatus, GitCommit } from '../../../../shared/src/interfaces/git.interface';
import simpleGit, { SimpleGit, LogResult, StatusResult } from 'simple-git';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

/**
 * Local Git Service implementation using simple-git
 * Stores repositories in a configurable base path
 */
export class LocalGitService implements IGitService {
  private basePath: string;

  constructor() {
    // Use environment variable or default to a path in the user's home directory
    this.basePath = process.env.GIT_BASE_PATH ||
      path.join(os.homedir(), '.kirby-gen-repos');
  }

  /**
   * Sanitize project ID to prevent path traversal and invalid characters
   */
  private sanitizeProjectId(projectId: string): string {
    // Remove path traversal attempts and special characters
    let sanitized = projectId.replace(/[^a-zA-Z0-9-_]/g, '-');

    // Remove any leading/trailing dots or slashes
    sanitized = sanitized.replace(/^[.\-\/]+|[.\-\/]+$/g, '');

    // Truncate to max filename length (255 chars on most systems)
    if (sanitized.length > 255) {
      sanitized = sanitized.substring(0, 255);
    }

    return sanitized || 'unnamed-project';
  }

  /**
   * Get the repository path for a project
   */
  private getRepoPath(projectId: string): string {
    const sanitizedId = this.sanitizeProjectId(projectId);
    return path.join(this.basePath, sanitizedId);
  }

  /**
   * Check if a repository exists
   */
  private async repoExists(projectId: string): Promise<boolean> {
    try {
      const repoPath = this.getRepoPath(projectId);
      await fs.access(repoPath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get a SimpleGit instance for a repository
   */
  private getGit(repoPath: string): SimpleGit {
    return simpleGit(repoPath);
  }

  /**
   * Create a new Git repository
   */
  async createRepo(projectId: string, initialCommit: boolean = true): Promise<string> {
    if (!projectId || projectId.trim() === '') {
      throw new Error('Project ID is required');
    }

    const repoPath = this.getRepoPath(projectId);

    try {
      // Create repository directory
      await fs.mkdir(repoPath, { recursive: true });

      // Initialize Git repository
      const git = this.getGit(repoPath);
      await git.init();

      // Configure Git user for this repository
      await git.addConfig('user.email', 'kirby-gen@local');
      await git.addConfig('user.name', 'Kirby Gen');

      // Create initial commit if requested
      if (initialCommit) {
        // Create a README file
        const readmeContent = `# ${projectId}\n\nGenerated by Kirby Gen\n`;
        const readmePath = path.join(repoPath, 'README.md');
        await fs.writeFile(readmePath, readmeContent);

        // Stage and commit
        await git.add('.');
        await git.commit('Initial commit');
      }

      return repoPath;
    } catch (error: any) {
      throw new Error(`Failed to create repository: ${error.message}`);
    }
  }

  /**
   * Commit changes to repository
   */
  async commit(projectId: string, message: string, files: string[]): Promise<string> {
    if (!projectId || projectId.trim() === '') {
      throw new Error('Project ID is required');
    }

    if (!message || message.trim() === '') {
      throw new Error('Commit message is required');
    }

    if (!files || files.length === 0) {
      throw new Error('At least one file is required');
    }

    if (!await this.repoExists(projectId)) {
      throw new Error(`Repository not found: ${projectId}`);
    }

    const repoPath = this.getRepoPath(projectId);
    const git = this.getGit(repoPath);

    try {
      // Add specified files
      await git.add(files);

      // Commit changes
      const result = await git.commit(message);

      // Extract commit SHA from result
      if (result && result.commit) {
        return result.commit;
      }

      throw new Error('Commit failed: no commit SHA returned');
    } catch (error: any) {
      throw new Error(`Failed to commit: ${error.message}`);
    }
  }

  /**
   * Push changes to remote (validates commits exist in local mode)
   */
  async push(projectId: string, remote: string = 'origin', branch: string = 'main'): Promise<void> {
    if (!projectId || projectId.trim() === '') {
      throw new Error('Project ID is required');
    }

    if (!await this.repoExists(projectId)) {
      throw new Error(`Repository not found: ${projectId}`);
    }

    const repoPath = this.getRepoPath(projectId);
    const git = this.getGit(repoPath);

    try {
      // In local mode, we just validate that commits exist
      const log = await git.log();

      if (!log || log.total === 0) {
        throw new Error('No commits to push');
      }

      // In a real implementation with a remote, we would:
      // await git.push(remote, branch);

      // For local mode, we just validate the repository state
      // The push is considered successful if there are commits
    } catch (error: any) {
      throw new Error(`Failed to push: ${error.message}`);
    }
  }

  /**
   * Get repository status
   */
  async getStatus(projectId: string): Promise<GitStatus> {
    if (!projectId || projectId.trim() === '') {
      throw new Error('Project ID is required');
    }

    if (!await this.repoExists(projectId)) {
      throw new Error(`Repository not found: ${projectId}`);
    }

    const repoPath = this.getRepoPath(projectId);
    const git = this.getGit(repoPath);

    try {
      const status: StatusResult = await git.status();

      // Extract file lists
      const staged = status.staged || [];
      const modified = status.modified || [];
      const notAdded = status.not_added || [];

      return {
        branch: status.current || 'unknown',
        ahead: status.ahead || 0,
        behind: status.behind || 0,
        staged: staged,
        unstaged: modified,
        untracked: notAdded
      };
    } catch (error: any) {
      throw new Error(`Failed to get status: ${error.message}`);
    }
  }

  /**
   * Get commit history
   */
  async getHistory(projectId: string, limit: number = 10): Promise<GitCommit[]> {
    if (!projectId || projectId.trim() === '') {
      throw new Error('Project ID is required');
    }

    if (!await this.repoExists(projectId)) {
      throw new Error(`Repository not found: ${projectId}`);
    }

    const repoPath = this.getRepoPath(projectId);
    const git = this.getGit(repoPath);

    try {
      const log: LogResult = await git.log({ maxCount: limit });

      if (!log || !log.all) {
        return [];
      }

      return log.all.map(commit => ({
        sha: commit.hash,
        message: commit.message,
        author: commit.author_name,
        email: commit.author_email,
        date: new Date(commit.date)
      }));
    } catch (error: any) {
      throw new Error(`Failed to get history: ${error.message}`);
    }
  }

  /**
   * Delete repository
   */
  async deleteRepo(projectId: string): Promise<void> {
    if (!projectId || projectId.trim() === '') {
      throw new Error('Project ID is required');
    }

    // Check if repository exists first
    if (!await this.repoExists(projectId)) {
      // Repository doesn't exist, nothing to delete
      return;
    }

    const repoPath = this.getRepoPath(projectId);

    try {
      // Remove the repository directory and all its contents
      await fs.rm(repoPath, { recursive: true, force: true });
    } catch (error: any) {
      throw new Error(`Failed to delete repository: ${error.message}`);
    }
  }
}